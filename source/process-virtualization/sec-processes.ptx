<?xml version="1.0" encoding="UTF-8"?>

<section xml:id="sec-processes" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Processes</title>
  <p>Start by reading the <url href="https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf">Process chapter</url> introduction (before 4.1).</p>
  <exercise label="ex-processes-intro">
    <statement>
      <p>The operating system implements <em>mechanisms</em> and <em>processes</em>. What do those refer to?</p>
    </statement>
    <choices>
      <choice>
        <statement><p>
          Mechanisms are pure hardware features that implement a needed piece of functionality.
        </p></statement>
      </choice>
      <choice correct="yes">
        <statement><p>
          Mechanisms are low level protocols that implement a needed piece of functionality.
        </p></statement>
      </choice>
      <choice>
        <statement><p>
          Mechanisms are function calls that implement a needed piece of functionality.
        </p></statement>
      </choice>
      <choice correct="yes">
        <statement><p>
          Policies are algorithms that the OS employs to make some decision.
        </p></statement>
      </choice>
      <choice>
        <statement><p>
          Policies are structured documents that the OS employs to make some decisions.
        </p></statement>
      </choice>
      <choice correct="yes">
        <statement><p>
          Implementing CPU virtualization requires both mechanisms and policies.
        </p></statement>
      </choice>
      <choice>
        <statement><p>
          A <em>context switch</em> is a policy.
        </p></statement>
      </choice>
      <choice correct="yes">
        <statement><p>
          Scheduling a process requires a policy.
        </p></statement>
      </choice>
    </choices>
  </exercise>
  <p>Read section 4.1 then answer this question.</p>
  <exercise label="ex-processes-process">
    <statement>
      <p>
        What parts of the machine state constitute a <em>process</em>?
      </p>
    </statement>
    <choices>
      <choice correct="yes">
        <statement>
          <p>the memory that the process can address</p>
        </statement>
      </choice>
      <choice correct="yes">
        <statement>
          <p>the values of the various registers</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>the file location in the disk that holds the process code</p>
        </statement>
        <feedback>
          <p>Process code is generally in memory once the process starts running, and changes to the disk version will not change the running program.</p>
        </feedback>
      </choice>
      <choice correct="yes">
        <statement>
          <p>the program counter</p>
        </statement>
      </choice>
      <choice correct="yes">
        <statement>
          <p>the files that the process has open</p>
        </statement>
      </choice>
      <choice correct="yes">
        <statement>
          <p>stack of function calls the process is currently executing</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>the results of function calls the process has completed</p>
        </statement>
        <feedback>
          <p>These would not be maintained anywhere long term.</p>
        </feedback>
      </choice>
    </choices>
  </exercise>
  <p>Read section 4.2 then answer this question.</p>
  <exercise label="ex-processes-api-capabilities">
    <statement>
      <p>What are the general capabilities expected of a modern process API?</p>
    </statement>
    <choices>
      <choice correct="yes">
        <statement>
          <p>creating new processes (by for example running a program from the shell)</p>
        </statement>
      </choice>
      <choice correct="yes">
        <statement>
          <p>forcefully stopping a process</p>
        </statement>
      </choice>
      <choice correct="no">
        <statement>
          <p>changings a process' id</p>
        </statement>
      </choice>
      <choice correct="yes">
        <statement>
          <p>waiting for a process to end</p>
        </statement>
      </choice>
      <choice correct="yes">
        <statement>
          <p>suspending a process' execution for a period of time</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>changing a process' arguments</p>
        </statement>
      </choice>
      <choice correct="yes">
        <statement>
          <p>finding out information about the running process, like how long it has been running for</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>allowing a process to access another process' information</p>
        </statement>
      </choice>
    </choices>
  </exercise>
  <p>Read section 4.3, about what goes on during process creation.</p>
  <exercise label="ex-processes-creation">
    <statement>
      <p>Which of the following are parts of the steps for creating a new process?</p>
    </statement>
    <choices>
      <choice correct="yes">
        <statement>
          <p>Reading the program code from disk into memory</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>Removing other processes from memory</p>
        </statement>
        <feedback>
          <p>This would not in general be needed, unless there is limited memory available. The OS can manage having multiple processes in memory at the same time.</p>
        </feedback>
      </choice>
      <choice correct="yes">
        <statement>
          <p>Allocating memory for the process' stack</p>
        </statement>
      </choice>
      <choice correct="yes">
        <statement>
          <p>Allocating memory for the process' heap</p>
        </statement>
      </choice>
      <choice correct="yes">
        <statement>
          <p>Setting up standard file descriptors</p>
        </statement>
      </choice>
    </choices>
  </exercise>
  <p>Read section 4.4 on process states.</p>
  <exercise label="ex-processes-states">
    <statement>
      <p>What are the states that a process can be in?</p>
    </statement>
    <choices>
      <choice correct="yes">
        <statement>
          <p>Ready</p>
        </statement>
      </choice>
      <choice correct="yes">
        <statement>
          <p>Running</p>
        </statement>
      </choice>
      <choice correct="no">
        <statement>
          <p>Suspended</p>
        </statement>
        <feedback>
          <p>A process that is suspended is actually in the ready state.</p>
        </feedback>
      </choice>
      <choice correct="yes">
        <statement>
          <p>Blocked</p>
        </statement>
      </choice>
      <choice correct="no">
        <statement>
          <p>Terminated</p>
        </statement>
        <feedback>
          <p>While it may be necessary to consider this state temporarily, terminated processes are simply removed from the system and their resources are reclaimed.</p>
        </feedback>
      </choice>
    </choices>
  </exercise>
  <exercise label="ex-processes-state-transitions">
    <statement>
      <p>Which of the following state transitions are possible, and as a result of what action?</p>
    </statement>
    <matches>
      <match>
        <premise order="1">Ready to Running</premise>
        <response>Possible by OS scheduling</response>
      </match>
      <match>
        <premise order="2">Running to Ready</premise>
        <response>Possible by OS interrupt</response>
      </match>
      <match>
        <premise order="3">Running to Blocked</premise>
        <response>Possible by I/O call</response>
      </match>
      <match>
        <premise order="4">Blocked to Running</premise>
        <response>Not possible</response>
      </match>
      <match>
        <premise order="5">Blocked to Ready</premise>
        <response>Possible by I/O return</response>
      </match>
    </matches>
  </exercise>
  <p>Read section 4.5 about the data structures used to represent a process. Also take a look at our xv6-riscv code, specifically <c>kernel/proc.h</c>. How do those definitions compare to what you see in the book? How do the process states map to the ones discussed in the book?</p>
  <exercise label="ex-processes-code-states-zombie">
    <statement>
      <p>Looking at the <c>proc_state</c> options in the code, which of those options describes the state of a process after it has been terminated but before it has been fully eliminated from the system?</p>
    </statement>
    <choices>
      <choice>
        <statement>
          <p><c>UNUSED</c></p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p><c>USED</c></p>
        </statement>
        <feedback>
          <p>No this is actually the state when the process structure is being set up.</p>
        </feedback>
      </choice>
      <choice>
        <statement>
          <p><c>SLEEPING</c></p>
        </statement>
        <feedback>
          <p>No, this is basically the blocked state.</p>
        </feedback>
      </choice>
      <choice correct="yes">
        <statement>
          <p><c>ZOMBIE</c></p>
        </statement>
        <feedback>
          <p>Unix programmers certainly have a weird sense of humor, right?</p>
        </feedback>
      </choice>
    </choices>
  </exercise>
  <exercise label="ex-processes-code-states-runnable">
    <statement>
      <p>Looking at the <c>proc_state</c> options in the code, which of those options describes the state of the process when it is in what the book described as the "ready" state?</p>
    </statement>
    <choices>
      <choice>
        <statement>
          <p><c>UNUSED</c></p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p><c>USED</c></p>
        </statement>
        <feedback>
          <p>No this is actually the state when the process structure is being set up.</p>
        </feedback>
      </choice>
      <choice correct="yes">
        <statement>
          <p><c>RUNNABLE</c></p>
        </statement>
        <feedback>
          <p>Very good!</p>
        </feedback>
      </choice>
      <choice>
        <statement>
          <p><c>SLEEPING</c></p>
        </statement>
        <feedback>
          <p>No, this is basically the blocked state.</p>
        </feedback>
      </choice>
      <choice>
        <statement>
          <p><c>RUNNING</c></p>
        </statement>
      </choice>
    </choices>
  </exercise>
  <exercise label="ex-processes-code-dive-num-procs">
    <statement>
      <p>Look at the <c>kernel/proc.c</c> file for the code that governs the creation of procedures. You should find there an array used to store <c>proc</c> objects (representing storage locations for running processes in the system). The number of entries in that array represents the maximum number of active processes in the system. How many concurrent processes does the xv6 system allow for? (You will need to search through other files to find where the constant is defined) <fillin characters="5" answer="64" mode="number" /></p>
    </statement>
    <evaluation>
      <evaluate>
        <test correct="yes"><numcmp use-answer="yes" /></test>
      </evaluate>
    </evaluation>
  </exercise>
  <exercise label="ex-processes-code-dive-allocid">
    <statement>
      <p>
        In <c>kernel/proc.c</c> you will find a function that is used to allocate a new "process id" (usually referred to as a <c>pid</c>) for a to-be-created process. Locate this function (you should recognize the acronym name of it when you see it). How does the system determine this pid?
      </p>
    </statement>
    <choices>
      <choice>
        <statement>
          <p>It selects a random integer, making sure the integer is not in use already.</p>
        </statement>
      </choice>
      <choice correct="yes">
        <statement>
          <p>It uses an ever-increasing integer counter.</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>It uses the index in the proc array where the process will be stored.</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>It uses the smallest positive integer that is not already being used (so if a process terminates, its process id can be used for a later process).</p>
        </statement>
      </choice>
    </choices>
  </exercise>
    <p>Now we look at the <url href="https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf">Process API chapter</url> which discusses important system calls that the kernel provides to enable us to manage processes. Start by reading section 5.1 about the <c>fork</c> system call, quite possibly the weirdest function you have seen. Compile and run the code in figure 5.1, which can also be found in the <c>ostep/cpu-api/p1.c</c> code file. (You can build all programs by doing <c>make all</c> from that directory, then delete them when you are done by running <c>make clean</c>.)</p>
    <p>Make sure you really understand which lines from that file are executed in the child process, which lines are executed in the parent, and which are executed in both.</p>
  <exercise label="ex-processes-api-fork-num-procs">
    <statement>
      <p>How many processes ended up running when we ran the program <c>p1</c>? <fillin characters="5" answer="2" mode="number" /></p>
    </statement>
    <evaluation>
      <evaluate>
        <test correct="yes"><numcmp use-answer="yes" /></test>
      </evaluate>
    </evaluation>
  </exercise>
  <exercise label="ex-processes-api-fork-child-start">
    <statement>
      <p>When a <c>fork</c> call happens, where does the child process start execution?</p>
    </statement>
    <choices>
      <choice>
        <statement>
          <p>In <c>main()</c>.</p>
        </statement>
      </choice>
      <choice correct="yes">
        <statement>
          <p>Exactly where the <c>fork</c> call happens.</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>At a location we specify as part of the <c>fork</c> call.</p>
        </statement>
      </choice>
    </choices>
  </exercise>
  <exercise label="ex-processes-api-fork-pids">
    <statement>
      <p>Suppose a process with pid 45 calls <c>fork</c> and this creates a child process with pid 87. Then the return value of the <c>fork()</c> call from the point of view of the parent is <fillin characters="5" answer="87" /> and the return value from the point of view of the child is <fillin characters="5" answer="0" /></p>
    </statement>
    <evaluation>
      <evaluate>
        <test correct="yes"><numcmp use-answer="yes" /></test>
      </evaluate>
      <evaluate>
        <test correct="yes"><numcmp use-answer="yes" /></test>
      </evaluate>
    </evaluation>
  </exercise>
  <exercise label="ex-processes-api-fork-fails">
    <statement>
      <p>
        What would happen if the attempt to <c>fork</c> a process fails (for example there is no room in the system for more processes)?
      </p>
    </statement>
    <choices>
      <choice correct="yes">
        <statement>
          <p>The <c>fork</c> call returns a negative number.</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>The system freezes.</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>An exception is thrown.</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>The <c>fork</c> call returns 0.</p>
        </statement>
      </choice>
    </choices>
  </exercise>
  <exercise label="ex-processes-api-fork-multiple">
    <statement>
      <p>This is a bit more open-ended: Change program 1 so that it creates a specific number of children (stored in some variable N). You need to be careful, as a naive approach by wrapping everything in a for loop will create many more children (e.g. 7 children if you ask it for 3).</p>
    </statement>
    <hint>
      <p>Each child continues execution exactly where the <c>fork()</c> call occurs, and if in the middle of the loop it means that the loop will also continue in the child process, not just in the parent process. You need to make sure children exit out of the for loop.</p>
    </hint>
  </exercise>
  <p>Now read through section 5.2, which discusses the <c>wait()</c> call that can be used by a process to wait for one of its children to end. Compile and run the program in Figure 5.2, also found in the file under <c>ostep/cpu-intro/p2.c</c>. </p>
  <exercise label="ex-processes-api-wait-return">
    <statement>
      <p>What is the return value of the <c>wait</c> call?</p>
    </statement>
    <choices>
      <choice>
        <statement>
          <p>There is no return value.</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>The time that the child process has been running for.</p>
        </statement>
      </choice>
      <choice correct="yes">
        <statement>
          <p>The pid of the terminated child.</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>The number of running children.</p>
        </statement>
      </choice>
    </choices>
  </exercise>
  <exercise label="ex-processes-api-wait-for-all-children">
    <statement>
      <p>If a process has multiple children, when does that the <c>wait</c> call return?</p>
    </statement>
    <choices>
      <choice>
        <statement>
          <p>Immediately.</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>When all the children have terminated.</p>
        </statement>
      </choice>
      <choice>
        <statement>
          <p>When the child with the smallest pid terminates.</p>
        </statement>
      </choice>
      <choice correct="yes">
        <statement>
          <p>When any child terminates.</p>
        </statement>
      </choice>
    </choices>
  </exercise>
  <exercise label="ex-processes-api-wait-multiple">
    <statement>
      <p>This is a bit more open-ended: Change this program p2 so that it creates a specific number of children (stored in some variable N), then waits for them all to finish and records the pids in the order the children finished. After that, it prints out all the pids in that same order.</p>
    </statement>
    <p>Now read section 5.3, which discusses the <c>exec</c> call. This is the call used to run a program different than the current program. Compile and run the program in Figure 5.3, that you can find in <c>ostep-code/cpu-api/p3.c</c>. </p>
  </exercise>
  <exercise label="ex-processes-api-exec-original">
    <statement>
      <p>When we use <c>execvp</c> to run another program, what happens to the original program?</p>
    </statement>
    <choices>
      <choice>
        <statement>
          <p>The original program continues executing just below the <c>execvp</c> line.</p>
        </statement>
      </choice>
      <choice correct="yes">
        <statement>
          <p>The original program doesn't run any more.</p>
        </statement>
        <feedback>
          <p>Read the documentation for <c>execvp</c> by running <c>man execvp</c>. What happens if the call fails to start the new program? Try to make the example p3 fail by calling a program that doesn't exist (for example <c>wce</c> instead of <c>wc</c>).</p>
        </feedback>
      </choice>
      <choice correct="yes">
        <statement>
          <p>The original program will only continue to run if there was an error in <c>execvp</c> executing the new program (for example if the file for the new program could not be found).</p>
        </statement>
      </choice>
    </choices>
  </exercise>
  <exercise label="ex-processes-api-exec-changed-example">
    <statement>
      <p>Modify the provided program so that it instead executes the <c>ls</c> program just as if we had typed: <c>ls -l ..</c>. You should see as a result a list of the different directories like <c>cpu-api</c>.</p>
    </statement>
    <hint>
      <p>You will need to extend the array used to provide arguments to the new program, as the call described above needs three different entries in the command line.</p>
    </hint>
  </exercise>
  <p>Read through sections 5.4 and 5.5 to get further understanding of how these tools are used, and in particular how the system manages multiple users and what they each can do.</p>
</section>
